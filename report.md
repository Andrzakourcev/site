## Лабораторная работа 3*

# Задание 

Сделать красиво работу с секретами. Например, поднять Hashicorp Vault (или другую секретохранилку) и сделать так, чтобы ci/cd пайплайн (или любой другой ваш сервис) ходил туда, брал секрет, использовал его не светя в логах. В Readme аргументировать почему ваш способ красивый, а также описать, почему хранение секретов в CI/CD переменных репозитория не является хорошей практикой.

# Ход выполнения

Для выполнения работы нам понадобится какой-либо проект, я взял свой старый (неоконченный, но это не так важно) тестовый проект по написанию сайта на Django. Я хочу скрыть свой SECRET_KEY, который нужен для верного функционированния сайта. В качестве секретохранилки я выбрал Hashicorp Vault. 

>  Hashicorp Vault – это хранилище секретных данных, любых. При этом данное хранилище поддерживает различные механизмы авторизации и политики доступа. Это сделано для разграничения прав к нашим данным.


# 1. Установка Vault

Это было неприятно, открыл виртуалку с линуксом --> зашел в браузер --> скачал google chrome --> скачал расширение впн --> зашел на сайт Hashicorp и скачал Vault.

После установки запускаем Vault командой:

`vault server -dev`

![image](https://github.com/user-attachments/assets/f46c59eb-4078-4034-9df4-1fefc8c481ad)

Получаем данное сообщение, в нем нам нужно VAULT_ADDR и Root Token. Также чтобы в последствии узнавать доступен ли vault, можно проверить что все работает командой `vault status`, если значение sealed - false, то vault активен. 

![image](https://github.com/user-attachments/assets/0c6053e3-811d-4d1c-a078-b3f155f3e878)

Далее с помощью данных команд авторизовываемся в Vault при помощи значений полученных ранее:

`export VAULT_ADDR=http://127.0.0.1:8200`

`export VAULT_TOKEN=<ваш_токен>'`

А также записываем наш секретный ключ:

`vault kv put secret/django SECRET_KEY="<сам ключ>"`

![image](https://github.com/user-attachments/assets/3ac1d649-1f78-452b-976e-0642a03ebe02)

При этом можно посмотреть метаданные и само значение командой:

`vault kv get <ваше название секрета>`

![image](https://github.com/user-attachments/assets/8a6587bb-8c38-4908-9398-6c6887c2d51d)

Также стоит сказать, что в рамках учебной задачи запускаемся локально, поэтому адрес 127.0.0.1:8200

# 2. Approle

Для авторизации в Vault я использовал Approle - метод авторизации Approle позволяет компьютерам или приложениям проходить аутентификацию с помощью ролей, определенных Vault. Этот метод аутентификации ориентирован на автоматизированные рабочие процессы (машины и сервисы) и менее полезен для людей-операторов.

Включаем данный метод:

`vault auth enable approle `

После создаем роль с информацией о политике, времени жизни токена и ключа (время взял из головы):

`
vault write auth/approle/role/my-role \
    policies="default" \
    secret_id_ttl="24h" \
    token_ttl="100h" \
    token_max_ttl="40h"
`

После получаем role_id:

`
vault read auth/approle/role/my-role/role-id
`

А также создаем новый secret_id:

`
vault write -f auth/approle/role/my-role/secret-id
`

![image](https://github.com/user-attachments/assets/cb0507ec-5324-4cb7-bc2a-d7a55c84c9f9)

Дальше нам следует записать role_id и secret_id в секреты репозитория, чтобы потом их брать уже в пайплайне.

![image](https://github.com/user-attachments/assets/1b8b4844-5c5d-4449-9a1e-1f959741b015)

# 3. Ngrok

Если мы оставим все как есть сейчас, то когда мы будем стараться подключиться к Vault'у, то раннер будет идти по указанному локальному адреса 127.0.0.1:8200 и ссылаться на себя же, поэтому воспользуемся Ngrok.

>  Ngrok - это сервис, который позволяет открыть доступ к внутренним ресурсам машины, на которой он запущен, из внешней сети, путем создания публичного адреса, все запросы на который будут переброшены на локальный адрес и заданный порт.

Регистрируемся у них на сайте, получаем токен. После устанавливаем на нам комп и добавляем токен

![image](https://github.com/user-attachments/assets/acf59c60-84df-4d10-bdd4-dbb3a7c7b553)

Теперь передаем порт:

`
ngrok http 8200
`

![image](https://github.com/user-attachments/assets/51a13ca6-c801-40d6-bc68-80c954102d86)

Находим наш публичнодоступный адрес, который делает переадресацию и сохраняем его в секретах гитхаба VAULT_ADDR.

# 4. Сам пайплайн

Теперь когда все настроено, можно написать сам пайплайн. В установочной job'е в одном из шагов мы подключаемся к Vault'у используя путь, roleId, secretId для Approle, которые мы уже сохранили в секретах репы. В следующем шаге мы получаем секретный ключ из Vault и сохраняем его в переменную окружения гитхаба. Стоит отметить, что это будет безопасно, так как её будет видно только в данном job или если через needs в следующих. Также, в логах этого не будет видно, если напрямую не выводить. 

![image](https://github.com/user-attachments/assets/b4ac0334-7490-4b5b-93a2-97f2a03b2947)

Также нам нужно будет немного изменить сам код программы, мы удаляем скроку с секретным кодом и вместо нее динамически получаем её из переменной окружения

![image](https://github.com/user-attachments/assets/74515791-0541-4f00-831b-2410a845d288)

![image](https://github.com/user-attachments/assets/00a8a03d-d526-4555-8022-dff0abe7487a)

Теперь все работает! Можно проверить запустив пайплайн!

![image](https://github.com/user-attachments/assets/0f27f0a0-0935-43a3-9c30-7685dd5a20a4)

Весь пайнлайн описывать не вижу смысла, его можно глянуть в workflows, там ничего особо интересного. Я определил что будет две job'ы, одна для установки всего необходимого, вторая для теста запуска приложения. Можно было ещё добавить, например, job'у с линтерами, но так как код не идеален, то опустим этот момент. Или например job'у для выхода на продакшен, но я остановися на тестовом запуске.

# Почему использование Vault красиво?

Секретная информация выносится из репозитория, что улучшает безопасность, расширенная политика доступа, различные методы аутентификации, версионирование данных, централизованное управление секретами и много чего ещё.

# Почему не стоит хранить секреты в репозитории?

Переменные в репозиториях часто не имеют должного уровня защиты. Если репозиторий не настроен должным образом или доступ к нему имеет много людей секреты могут быть случайно раскрыты. Также нет встроенной системы аудита для секретов. 



